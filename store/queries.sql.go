// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: queries.sql

package store

import (
	"context"
)

const createFile = `-- name: CreateFile :one
INSERT INTO files (parent, name, file_type, length, last_write_at, last_access_at) VALUES (?, ?, ?, ?, ?, ?)
RETURNING file_id
`

type CreateFileParams struct {
	Parent       int64
	Name         string
	FileType     int64
	Length       int64
	LastWriteAt  int64
	LastAccessAt int64
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createFile,
		arg.Parent,
		arg.Name,
		arg.FileType,
		arg.Length,
		arg.LastWriteAt,
		arg.LastAccessAt,
	)
	var file_id int64
	err := row.Scan(&file_id)
	return file_id, err
}

const deleteFile = `-- name: DeleteFile :execrows
DELETE FROM files WHERE file_id = ?
`

func (q *Queries) DeleteFile(ctx context.Context, fileID int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteFile, fileID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deletePage = `-- name: DeletePage :execrows
DELETE FROM pages WHERE file_id = ? AND page_num = ? AND page_size_power = ?
`

type DeletePageParams struct {
	FileID        int64
	PageNum       int64
	PageSizePower int64
}

func (q *Queries) DeletePage(ctx context.Context, arg DeletePageParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deletePage, arg.FileID, arg.PageNum, arg.PageSizePower)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getDirectoryFiles = `-- name: GetDirectoryFiles :many
SELECT file_id, parent, name, file_type, length, last_write_at, last_access_at FROM files WHERE parent = ?
`

func (q *Queries) GetDirectoryFiles(ctx context.Context, parent int64) ([]File, error) {
	rows, err := q.db.QueryContext(ctx, getDirectoryFiles, parent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.FileID,
			&i.Parent,
			&i.Name,
			&i.FileType,
			&i.Length,
			&i.LastWriteAt,
			&i.LastAccessAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFile = `-- name: GetFile :one





SELECT file_id, parent, name, file_type, length, last_write_at, last_access_at FROM files WHERE file_id = ?
`

// CREATE TABLE IF NOT EXISTS files (
//
//	file_id         INTEGER       PRIMARY KEY AUTOINCREMENT,
//	parent          INTEGER       NOT NULL,
//	name            VARCHAR(4096) NOT NULL,
//	file_type       TINYINT       NOT NULL,
//	length          INTEGER       NOT NULL,
//	last_write_at   INTEGER       NOT NULL, -- unix timestamp in millis
//	last_access_at  INTEGER       NOT NULL -- unix timestamp in millis
//
// );
// INSERT OR IGNORE INTO files (file_id, parent, name, file_type, length, last_write_at, last_access_at) VALUES (0, 0, '__internal_stub_1', 0, 0, 0, 0);
// INSERT OR IGNORE INTO files (file_id, parent, name, file_type, length, last_write_at, last_access_at) VALUES (1, 0, '__internal_stub_2', 0, 0, 0, 0);
// INSERT OR IGNORE INTO files (file_id, parent, name, file_type, length, last_write_at, last_access_at) VALUES (2, 0, '__internal_root', 0, 0, 0, 0);
// CREATE INDEX IF NOT EXISTS files_last_access_at ON files (last_access_at);
// CREATE INDEX IF NOT EXISTS files_parent ON files (parent);
// CREATE TABLE IF NOT EXISTS pages (
//
//	file_id         INTEGER       NOT NULL,
//	page_num        INTEGER       NOT NULL,
//	page_size_power TINYINT       NOT NULL,
//	data            BLOB          NOT NULL
//	PRIMARY KEY (file_id, page_num, page_size_power)
//
// );
// CREATE INDEX IF NOT EXISTS pages_last_access_at ON pages (last_access_at);
func (q *Queries) GetFile(ctx context.Context, fileID int64) (File, error) {
	row := q.db.QueryRowContext(ctx, getFile, fileID)
	var i File
	err := row.Scan(
		&i.FileID,
		&i.Parent,
		&i.Name,
		&i.FileType,
		&i.Length,
		&i.LastWriteAt,
		&i.LastAccessAt,
	)
	return i, err
}

const getFileInDirectory = `-- name: GetFileInDirectory :one
SELECT file_id, parent, name, file_type, length, last_write_at, last_access_at FROM files WHERE parent = ? AND name = ?
`

type GetFileInDirectoryParams struct {
	Parent int64
	Name   string
}

func (q *Queries) GetFileInDirectory(ctx context.Context, arg GetFileInDirectoryParams) (File, error) {
	row := q.db.QueryRowContext(ctx, getFileInDirectory, arg.Parent, arg.Name)
	var i File
	err := row.Scan(
		&i.FileID,
		&i.Parent,
		&i.Name,
		&i.FileType,
		&i.Length,
		&i.LastWriteAt,
		&i.LastAccessAt,
	)
	return i, err
}

const getPage = `-- name: GetPage :one
SELECT data FROM pages WHERE file_id = ? AND page_num = ? AND page_size_power = ?
`

type GetPageParams struct {
	FileID        int64
	PageNum       int64
	PageSizePower int64
}

func (q *Queries) GetPage(ctx context.Context, arg GetPageParams) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, getPage, arg.FileID, arg.PageNum, arg.PageSizePower)
	var data []byte
	err := row.Scan(&data)
	return data, err
}

const renameFile = `-- name: RenameFile :execrows
UPDATE files SET parent = ?, name = ? WHERE file_id = ?
`

type RenameFileParams struct {
	Parent int64
	Name   string
	FileID int64
}

func (q *Queries) RenameFile(ctx context.Context, arg RenameFileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, renameFile, arg.Parent, arg.Name, arg.FileID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateFile = `-- name: UpdateFile :exec
UPDATE files SET parent = ?, name = ?, file_type = ?, length = ?, last_write_at = ?, last_access_at = ? WHERE file_id = ?
`

type UpdateFileParams struct {
	Parent       int64
	Name         string
	FileType     int64
	Length       int64
	LastWriteAt  int64
	LastAccessAt int64
	FileID       int64
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) error {
	_, err := q.db.ExecContext(ctx, updateFile,
		arg.Parent,
		arg.Name,
		arg.FileType,
		arg.Length,
		arg.LastWriteAt,
		arg.LastAccessAt,
		arg.FileID,
	)
	return err
}

const upsertPage = `-- name: UpsertPage :exec
INSERT INTO pages (file_id, page_num, page_size_power, data)
VALUES (?, ?, ?, ?)
ON CONFLICT (file_id, page_num, page_size_power) DO UPDATE SET
    data = excluded.data
`

type UpsertPageParams struct {
	FileID        int64
	PageNum       int64
	PageSizePower int64
	Data          []byte
}

func (q *Queries) UpsertPage(ctx context.Context, arg UpsertPageParams) error {
	_, err := q.db.ExecContext(ctx, upsertPage,
		arg.FileID,
		arg.PageNum,
		arg.PageSizePower,
		arg.Data,
	)
	return err
}
